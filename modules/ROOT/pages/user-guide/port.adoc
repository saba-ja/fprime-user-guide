= Port

== What is F Prime Port

In the context of F Prime framework, a "port" refers to a communication interface that connects components within the flight software system. Ports serve as conduits for sending and receiving data, commands, events, or telemetry between different components. You can think of a port as the endpoint of a connection between two component instances.

image::fprime_ports.drawio.png[F Prime Port Illustration]

== Port Design vs Port Instantiation

When talking about ports, it's important to differentiate between the "port design" and "port instantiation". The design of a port specifies its type (name, arguments, etc.). The "port design" doesn't determine how the port is used by a component, such as its directionality, synchronous or asynchronous nature, or whether it's guarded or not. These usage details are specified during the instantiation of a port when it is used by a component.

image::port_definition_vs_port_instance.drawio.png[Port Definition vs Port Instances]

== Instantiating F Prime Ports

To use an F Prime port, the user needs to instantiate the port in the component's FPP specification. The port can be an instance of one of the F Prime predefined ports or one of the custom ports defined by the user. The process of defining custom ports will be covered later in this document.

Like in object-oriented programming, a "port instance" is created using a "port definition". The "port definition" holds information that applies to all instances of the port, like the type of data that can pass through it. On the other hand, the "port instance" contains specific details that are unique to its usage, such as the kind of port instance (async input, sync input, guarded input, output), the "port instance" name, and the type of instance which refers to the "port definition".

[source,fpp]
----
<async input, sync input, guarded input, output> port <PortInstanceName>: [[ArraySize]] <PortType> [priority NUMBER] [assert, block, drop]
----

Here is an example of port instantiation:

[source,fpp]
----
active component Led {

    sync input port run: Svc.Sched

    output port gpioSet: Drv.GpioWrite
}
----

Let's break down the code:

`active component Led` line declares the start of a new component named "Led."

`sync input port run: Svc.Sched` line declares a synchronous input port named "run," which is associated with the "Svc.Sched" interface. The "Svc.Sched" interface represents a scheduler service will be repeating based on a given "rate group".

`output port gpioSet: Drv.GpioWrite` line declares an output port named "gpioSet," which is associated with the "Drv.GpioWrite" interface. The "Drv.GpioWrite" interface provides functionality to control the GPIO (General Purpose Input/Output) pins of a hardware device, such as setting the output state of a pin.

NOTE: Both the link:https://github.com/nasa/fprime/blob/master/Svc/Sched/Sched.fpp[Svc.Sched] and link:https://github.com/nasa/fprime/blob/master/Drv/GpioDriverPorts/GpioDriverPorts.fpp[Drv.GpioWrite] are predefined F Prime ports.


NOTE: Previously mentioned, there is a technical difference between a port type (defined outside any component, indicating the type of a port instance) and a port instance (defined inside a component, representing an instance of a port type). However, for the sake of simplicity, we will occasionally refer to a port instance as just a "port" in this manual, as long as it doesn't cause any confusion.

== Port Instance Kinds

A Port instance can have one of the following types:

* `async input`: This type of port receives input for the component through a message queue. The input is then processed either on the thread of the component itself (if the component is active) or on the thread of another port invocation (if the component is queued).
* `sync input`: This type of port receives input that directly invokes a handler defined within the component. The input is processed on the thread of the caller, the entity that triggered the input.
* `guarded input`: Similar to sync input, this type of port also receives input that invokes a handler within the component. However, the handler is guarded by a mutual exclusion lock, ensuring that only one thread can access it at a time to prevent conflicts or race conditions.
* `output`: This type of port is responsible for transmitting output from the component to other parts of the system or components. It facilitates the flow of information or data generated by the component to be used elsewhere.



[source,fpp]
----
port F32Value(value: F32)

passive component F32Adder {

  sync input port f32ValueIn1: F32Value

  sync input port f32ValueIn2: F32Value

  output port f32ValueOut: F32Value

}
----

The code above defines a component called "F32Adder" that performs addition on 32-bit floating-point values. Let's break down the code:

* `port F32Value(value: F32)`: This line defines a port type called F32Value, which represents a 32-bit floating-point value. The value parameter indicates that this port type expects a value of type F32.
* `passive component F32Adder`: This line defines a passive component called F32Adder. A passive component is a reusable module that doesn't have its own thread of execution and relies on external events to trigger its behavior.
* `sync input port f32ValueIn1`: F32Value: This line declares a synchronous input port called f32ValueIn1. Synchronous means that the component expects to receive data on this port and will wait for it to be available before proceeding. The port is of type F32Value, which means it can receive a 32-bit floating-point value.
* `sync input port f32ValueIn2`: F32Value: Similar to the previous line, this declares another synchronous input port called f32ValueIn2 of type F32Value.
* `output port f32ValueOut`: F32Value: This line declares an output port called f32ValueOut of type F32Value. This port will be used to send the result of the addition operation.

NOTE: The example code above doesn't explicitly show the implementation details of the addition operation, but it defines the input and output ports of the component.

== Arrays of Port Instances

When you use a port instance as part of an FPP component, you're actually using an array of port instances. Each instance in the array has a port number, starting at zero and incrementing by one for each subsequent element. In other words, the port numbers correspond to the array indices, which begin at zero.

If you don't specify a size for the array, as shown in the previous examples, it defaults to size one, meaning there is a single port instance with port number zero. In essence, a port instance specifier without an array size behaves like a single element array. However, you can also specify an explicit array size by enclosing a size expression in square brackets \[ ... \], indicating the number of elements in the array. The size expression must be a numerical value. Similar to array type definitions, the size comes before the element type. As an example, here's another version of the F32Adder component that uses a single array with two input ports instead of two named ports.

[source,fpp]
----
port F32Value(value: F32)

passive component F32Adder {

  sync input port f32ValueIn: [2] F32Value

  output port f32ValueOut: F32Value
}
----

== Port Instance Priority

For `async input` ports, you may specify a priority.
The priority specification is not allowed for other kinds of ports.
The priorities regulate the order in which elements are dispatched
from the message queue. Requests coming from ports with higher priority will have precedence over other ports.

To specify a priority, you write the keyword `priority` and an
expression that evaluates to a numeric value after the port type.
As an example, here is a modified version of the `ActiveF32Adder`
with specified priorities:

[source,fpp]
----
port F32Value(value: F32)

active component ActiveF32Adder {

  async input port f32ValueIn1: F32Value priority 10

  async input port f32ValueIn2: F32Value priority 20

  output port f32ValueOut: F32Value

}
----

If an `async input` port has no specified priority, then the
translator uses a default priority.
The precise meaning of the default priority and of the numeric priorities is
implementation-specific.


== Port Instance async input Queue Full Behavior

By default, if an invocation of an `async input` port causes
a message queue to overflow, then a *FSW assertion* fails.
A FSW assertion is a condition that must be true in order
for FSW execution to proceed safely.
The behavior of a FSW assertion failure is configurable in the {cpp}
implementation of the F Prime framework; typically it causes a FSW
abort and system reset.

Optionally, you can specify the behavior when a message
received on an `async` `input` port causes a queue overflow.
There are three possible behaviors:

. `assert`: Fail a FSW assertion (the default behavior).
. `block`: Block the sender until the queue is available.
. `drop`: Drop the incoming message and proceed.

To specify queue full behavior, you write one of the keywords `assert`,
`block`, or `drop` after the port type and after the priority
(if any).
As an example, here is the `ActiveF32Adder` updated with explicit
queue full behavior.

[source,fpp]
----
@ A port for carrying an F32 value
port F32Value(value: F32)

@ An active component for adding two F32 values
@ Uses specified priorities
active component ActiveF32Adder {

  @ Input 1 at priority 10: Block on queue full
  async input port f32ValueIn1: F32Value priority 10 block

  @ Input 2: Drop on queue full
  async input port f32ValueIn2: F32Value drop

  @ Output
  output port f32ValueOut: F32Value

}
----

As for priority specifiers, queue full specifiers are allowed only
for `async input` ports.

== Annotating a Port

A port definition is an annotatable element. Each formal parameter is also an annotatable element. Here is an example:

[source,fpp]
----
@ Pre annotation for port P
port P(
  @ Pre annotation for parameter a
  a: U32
  @ Pre annotation for parameter b
  b: F32
)
----


== Rules for Port Instances

The port instances appearing in a component definition must
satisfy certain rules.
These rules ensure that the FPP model makes sense.

First, no passive component may have an `async` `input`
port.
This is because a passive component has no message queue,
so asynchronous input is not possible.
As an example, if we modify the input ports of our `F32Adder`
to make them `async`, we get an error.

[source,fpp]
----
port F32Value(value: F32)

# Error: Passive component may not have async input
passive component ErroneousF32Adder {

  async input port f32ValueIn1: F32Value

  async input port f32ValueIn2: F32Value

  output port f32ValueOut: F32Value

}
----

Second, an active or queued component _must_ have asynchronous input.
That means it must have at least one async input port;
or it must have an internal port (described below);
or it must have at least one async command (also described below).
As an example, if we modify the input ports of our `ActiveF32Adder`
to make them `sync`, we get an error, because
there is no async input.

[source,fpp]
----
port F32Value(value: F32)

# Error: Active component must have async input
active component ErroneousActiveF32Adder {

  sync input port f32ValueIn1: F32Value

  sync input port f32ValueIn2: F32Value

  output port f32ValueOut: F32Value

}
----

Third, a port type appearing in an `async` `input` port
may not have a return type.
This is because returning a value
makes sense only for synchronous input.
As an example, this component definition is illegal:

[source,fpp]
----
port P -> U32

active component Error {

  # Error: port instance p: P is async input and
  # port P has a return type
  async input port p: P

}
----

Fourth, only `async input` ports can have priority. The priority specification is not allowed for other kinds of ports.


In summary the following rules must be followed when instantiating ports:

* No `passive` component may have an `async input` port.
* An `active` or `queued` component must have at least one asynchronous input.
* A port type appearing in an `async input` port may not have a return type.
* Only `async input` ports can have priority.

== Serial Port Instances

In the example above, each port instance needs to have a specific data type, which defines what kind of data can be sent through that port. Ports can only connect to other ports that have the same data type. However, there may be cases where we don't want to enforce these port types and instead want to pass data between components as a general block of data.

To address this, F Prime has a feature called serialization. Serialization allows us to take the arguments supplied to a port and convert them into a data buffer. Serialization ports are special ports designed to handle serialized buffers without automatically unpacking them. Any output port type can be connected to a serialization port input type, and any serialization output port can be connected to any input port type. This allows strongly-typed ports to connect to generic "pass-any-data" serialization ports, as depicted in Figure below.

image::core3.png[Serialization ports, width=640,height=480]

The framework supports serialized ports, which enable users to send both basic and custom data types. Serialization takes a set of typed values or function arguments and converts them into a data buffer in a way that is independent of the underlying system architecture.

When a port call is serialized, its commands and arguments are converted into a serialized format and placed in message queues in the receiving component. Users can define various types of interface arguments, and the framework automatically handles the serialization of data for port calls. Complex types can be defined using XML, and a code generator can generate serializable classes for internal use and integration with the F' supplied ground system.

For input ports, when a connection is detected, the calling port serializes the arguments before sending them. For output ports, the serialized port calls an interface on the typed port that deserializes the arguments. However, serialization ports do not support ports with return types.

In summary serialization ports enable the transfer of serialized data between generic components that do not have knowledge of the specific data type contained in the buffer. This is useful for scenarios where data needs to be passed across different components without them needing to know the exact type of data being transmitted. Serialization ports are particularly useful for generic storage and communication components that don't require knowledge of the specific data types they handle. This allows the design and implementation of command and data handling (C&DH) components that can be reused. Tested C&DH components are typically developed to implement common flight functions that are not mission-specific.



== Defining Port

A port definition defines an F Prime port. A port definition specifies the name of the port, the type of the data carried on the port, and an optional return type.

[source,fpp]
----
port <PortName>[(parameterName: ParameterType, ...)] [-> returnType]
----

== Port Name

The simplest port definition consists of the keyword `port` followed by a name. For example:

[source,fpp]
----
port MyPort
----

The provided code creates a port called MyPort that has no input or output data. Such a port can be useful for sending or receiving a trigger event.

== Port Parameters

In most cases, a port is used to transmit data. To specify the data, you can define port parameters by enclosing them in parentheses. The parameters in a port definition is similar to a function definition in a programming language. Each parameter has a name and a type, and you can include any number of parameters. Here's an example to illustrate this:

[source,fpp]
----
port P1() # Zero parameters; equivalent to port P1
port P2(a: U32) # One parameter
port P3(a: I32, b: F32, c: string) # Three parameters
----

The type of a formal parameter may be any valid type, including an array type, a struct type, an enum type, or an abstract type. For example, here is some code that defines an enum type E and and abstract type T, and then uses those types in the formal parameters of a port:

[source,fpp]
----
enum E { A, B }
type T
port P(e: E, t: T)
----

Parameters in a port definition are written as a sequence of elements, and they can be separated by commas. However, it is also acceptable to omit the comma and use a newline instead. This means that the definition mentioned earlier can be written in the following alternate format:

[source,fpp]
----
enum E { A, B }
type T
port P(
  e: E
  t: T
)
----