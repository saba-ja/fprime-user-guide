= Port

== What is F Prime Port

In the context of F Prime framework, a "port" refers to a communication interface that connects components within the flight software system. Ports serve as conduits for sending and receiving data, commands, events, or telemetry between different components. You can think of a port as the endpoint of a connection between two component instances.

image::fprime_ports.drawio.png[F Prime Port Illustration]

== Port Design vs Port Instantiation

When talking about ports, it's important to differentiate between the "port design" and "port instantiation". The design of a port specifies its type (name, arguments, etc.). The "port design" doesn't determine how the port is used by a component, such as its directionality, synchronous or asynchronous nature, or whether it's guarded or not. These usage details are specified during the instantiation of a port when it is used by a component.

image::port_definition_vs_port_instance.drawio.png[Port Definition vs Port Instances]

== Instantiating F Prime Ports

To use an F Prime port, the user needs to instantiate the port in the component's FPP specification. The port can be an instance of one of the F Prime predefined ports or one of the custom ports defined by the user. The process of defining custom ports will be covered later in this document.

Like in object-oriented programming, a "port instance" is created using a "port definition". The "port definition" holds information that applies to all instances of the port, like the type of data that can pass through it. On the other hand, the "port instance" contains specific details that are unique to its usage, such as the kind of port instance (async input, sync input, guarded input, output), the "port instance" name, and the type of instance which refers to the "port definition".

[source,fpp]
----
<async input, sync input, guarded input, output> port <PortInstanceName>: [[ArraySize]] <PortType> [priority NUMBER] [assert, block, drop]
----

Here is an example of port instantiation:

[source,fpp]
----
active component Led {

    sync input port run: Svc.Sched

    output port gpioSet: Drv.GpioWrite
}
----

Let's break down the code:

`active component Led` line declares the start of a new component named "Led."

`sync input port run: Svc.Sched` line declares a synchronous input port named "run," which is associated with the "Svc.Sched" interface. The "Svc.Sched" interface represents a scheduler service will be repeating based on a given "rate group".

`output port gpioSet: Drv.GpioWrite` line declares an output port named "gpioSet," which is associated with the "Drv.GpioWrite" interface. The "Drv.GpioWrite" interface provides functionality to control the GPIO (General Purpose Input/Output) pins of a hardware device, such as setting the output state of a pin.

NOTE: Both the link:https://github.com/nasa/fprime/blob/master/Svc/Sched/Sched.fpp[Svc.Sched] and link:https://github.com/nasa/fprime/blob/master/Drv/GpioDriverPorts/GpioDriverPorts.fpp[Drv.GpioWrite] are predefined F Prime ports.


NOTE: Previously mentioned, there is a technical difference between a port type (defined outside any component, indicating the type of a port instance) and a port instance (defined inside a component, representing an instance of a port type). However, for the sake of simplicity, we will occasionally refer to a port instance as just a "port" in this manual, as long as it doesn't cause any confusion.

== Port Instance Kinds

A Port instance can have one of the following types:

* `async input`: This type of port receives input for the component through a message queue. The input is then processed either on the thread of the component itself (if the component is active) or on the thread of another port invocation (if the component is queued).
* `sync input`: This type of port receives input that directly invokes a handler defined within the component. The input is processed on the thread of the caller, the entity that triggered the input.
* `guarded input`: Similar to sync input, this type of port also receives input that invokes a handler within the component. However, the handler is guarded by a mutual exclusion lock, ensuring that only one thread can access it at a time to prevent conflicts or race conditions.
* `output`: This type of port is responsible for transmitting output from the component to other parts of the system or components. It facilitates the flow of information or data generated by the component to be used elsewhere.



[source,fpp]
----
port F32Value(value: F32)

passive component F32Adder {

  sync input port f32ValueIn1: F32Value

  sync input port f32ValueIn2: F32Value

  output port f32ValueOut: F32Value

}
----

The code above defines a component called "F32Adder" that performs addition on 32-bit floating-point values. Let's break down the code:

* `port F32Value(value: F32)`: This line defines a port type called F32Value, which represents a 32-bit floating-point value. The value parameter indicates that this port type expects a value of type F32.
* `passive component F32Adder`: This line defines a passive component called F32Adder. A passive component is a reusable module that doesn't have its own thread of execution and relies on external events to trigger its behavior.
* `sync input port f32ValueIn1`: F32Value: This line declares a synchronous input port called f32ValueIn1. Synchronous means that the component expects to receive data on this port and will wait for it to be available before proceeding. The port is of type F32Value, which means it can receive a 32-bit floating-point value.
* `sync input port f32ValueIn2`: F32Value: Similar to the previous line, this declares another synchronous input port called f32ValueIn2 of type F32Value.
* `output port f32ValueOut`: F32Value: This line declares an output port called f32ValueOut of type F32Value. This port will be used to send the result of the addition operation.

NOTE: The example code above doesn't explicitly show the implementation details of the addition operation, but it defines the input and output ports of the component.

== Arrays of Port Instances

When you use a port instance as part of an FPP component, you're actually using an array of port instances. Each instance in the array has a port number, starting at zero and incrementing by one for each subsequent element. In other words, the port numbers correspond to the array indices, which begin at zero.

If you don't specify a size for the array, as shown in the previous examples, it defaults to size one, meaning there is a single port instance with port number zero. In essence, a port instance specifier without an array size behaves like a single element array. However, you can also specify an explicit array size by enclosing a size expression in square brackets \[ ... \], indicating the number of elements in the array. The size expression must be a numerical value. Similar to array type definitions, the size comes before the element type. As an example, here's another version of the F32Adder component that uses a single array with two input ports instead of two named ports.

[source,fpp]
----
port F32Value(value: F32)

passive component F32Adder {

  sync input port f32ValueIn: [2] F32Value

  output port f32ValueOut: F32Value
}
----

== Port Instance Priority

For `async input` ports, you may specify a priority.
The priority specification is not allowed for other kinds of ports.
The priorities regulate the order in which elements are dispatched
from the message queue. Requests coming from ports with higher priority will have precedence over other ports.

To specify a priority, you write the keyword `priority` and an
expression that evaluates to a numeric value after the port type.
As an example, here is a modified version of the `ActiveF32Adder`
with specified priorities:

[source,fpp]
----
port F32Value(value: F32)

active component ActiveF32Adder {

  async input port f32ValueIn1: F32Value priority 10

  async input port f32ValueIn2: F32Value priority 20

  output port f32ValueOut: F32Value

}
----

If an `async input` port has no specified priority, then the
translator uses a default priority.
The precise meaning of the default priority and of the numeric priorities is
implementation-specific.


== Port Instance async input Queue Full Behavior

By default, if an invocation of an `async input` port causes
a message queue to overflow, then a *FSW assertion* fails.
A FSW assertion is a condition that must be true in order
for FSW execution to proceed safely.
The behavior of a FSW assertion failure is configurable in the {cpp}
implementation of the F Prime framework; typically it causes a FSW
abort and system reset.

Optionally, you can specify the behavior when a message
received on an `async` `input` port causes a queue overflow.
There are three possible behaviors:

. `assert`: Fail a FSW assertion (the default behavior).
. `block`: Block the sender until the queue is available.
. `drop`: Drop the incoming message and proceed.

To specify queue full behavior, you write one of the keywords `assert`,
`block`, or `drop` after the port type and after the priority
(if any).
As an example, here is the `ActiveF32Adder` updated with explicit
queue full behavior.

[source,fpp]
----
@ A port for carrying an F32 value
port F32Value(value: F32)

@ An active component for adding two F32 values
@ Uses specified priorities
active component ActiveF32Adder {

  @ Input 1 at priority 10: Block on queue full
  async input port f32ValueIn1: F32Value priority 10 block

  @ Input 2: Drop on queue full
  async input port f32ValueIn2: F32Value drop

  @ Output
  output port f32ValueOut: F32Value

}
----

As for priority specifiers, queue full specifiers are allowed only
for `async input` ports.

== Annotating a Port

A port definition is an annotatable element. Each formal parameter is also an annotatable element. Here is an example:

[source,fpp]
----
@ Pre annotation for port P
port P(
  @ Pre annotation for parameter a
  a: U32
  @ Pre annotation for parameter b
  b: F32
)
----


== Rules for Port Instances

The port instances appearing in a component definition must
satisfy certain rules.
These rules ensure that the FPP model makes sense.

First, no passive component may have an `async` `input`
port.
This is because a passive component has no message queue,
so asynchronous input is not possible.
As an example, if we modify the input ports of our `F32Adder`
to make them `async`, we get an error.

[source,fpp]
----
port F32Value(value: F32)

# Error: Passive component may not have async input
passive component ErroneousF32Adder {

  async input port f32ValueIn1: F32Value

  async input port f32ValueIn2: F32Value

  output port f32ValueOut: F32Value

}
----

Second, an active or queued component _must_ have asynchronous input.
That means it must have at least one async input port;
or it must have an internal port (described below);
or it must have at least one async command (also described below).
As an example, if we modify the input ports of our `ActiveF32Adder`
to make them `sync`, we get an error, because
there is no async input.

[source,fpp]
----
port F32Value(value: F32)

# Error: Active component must have async input
active component ErroneousActiveF32Adder {

  sync input port f32ValueIn1: F32Value

  sync input port f32ValueIn2: F32Value

  output port f32ValueOut: F32Value

}
----

Third, a port type appearing in an `async` `input` port
may not have a return type.
This is because returning a value
makes sense only for synchronous input.
As an example, this component definition is illegal:

[source,fpp]
----
port P -> U32

active component Error {

  # Error: port instance p: P is async input and
  # port P has a return type
  async input port p: P

}
----

Fourth, only `async input` ports can have priority. The priority specification is not allowed for other kinds of ports.


In summary the following rules must be followed when instantiating ports:

* No `passive` component may have an `async input` port.
* An `active` or `queued` component must have at least one asynchronous input.
* A port type appearing in an `async input` port may not have a return type.
* Only `async input` ports can have priority.

== Serial Port Instances

In the example above, each port instance needs to have a specific data type, which defines what kind of data can be sent through that port. Ports can only connect to other ports that have the same data type. However, there may be cases where we don't want to enforce these port types and instead want to pass data between components as a general block of data.

To address this, F Prime has a feature called serialization. Serialization allows us to take the arguments supplied to a port and convert them into a data buffer. Serialization ports are special ports designed to handle serialized buffers without automatically unpacking them. Any output port type can be connected to a serialization port input type, and any serialization output port can be connected to any input port type. This allows strongly-typed ports to connect to generic "pass-any-data" serialization ports, as depicted in Figure below.

image::core3.png[Serialization ports, width=640,height=480]

The framework supports serialized ports, which enable users to send both basic and custom data types. Serialization takes a set of typed values or function arguments and converts them into a data buffer in a way that is independent of the underlying system architecture.

When a port call is serialized, its commands and arguments are converted into a serialized format and placed in message queues in the receiving component. Users can define various types of interface arguments, and the framework automatically handles the serialization of data for port calls. Complex types can be defined using XML, and a code generator can generate serializable classes for internal use and integration with the F' supplied ground system.

For input ports, when a connection is detected, the calling port serializes the arguments before sending them. For output ports, the serialized port calls an interface on the typed port that deserializes the arguments. However, serialization ports do not support ports with return types.

In summary serialization ports enable the transfer of serialized data between generic components that do not have knowledge of the specific data type contained in the buffer. This is useful for scenarios where data needs to be passed across different components without them needing to know the exact type of data being transmitted. Serialization ports are particularly useful for generic storage and communication components that don't require knowledge of the specific data types they handle. This allows the design and implementation of command and data handling (C&DH) components that can be reused. Tested C&DH components are typically developed to implement common flight functions that are not mission-specific.

== Defining Serial Port Instances in FPP

When writing a port instance, instead of specifying a named port type, you may write the keyword serial. Doing this specifies a serial port instance. A serial port instance does not specify the type of data that it carries. It may be connected to a port of any type. Serial data passes through the port; the data may be converted to or from a specific type at the other end of the connection.

As an example, here is a passive component for taking a stream of serial data and splitting it (i.e., repeating it by copy) onto several streams:

[source,fpp]
----
@ Split factor
constant splitFactor = 10

@ Component for splitting a serial data stream
passive component SerialSplitter {

  @ Input
  sync input port serialIn: serial

  @ Output
  output port serialOut: [splitFactor] serial

}
----

By using serial ports, you can send several unrelated types of data over the same port connection. This technique is useful when communicating across a network: on each side of the network connection, a single component can act as a hub that routs all data to and from components on that side. This flexibility comes at the cost that you lose the type compile-time type checking provided by port connections with named types. 

== Serial Port Instances

When writing a port instance, instead of specifying a named port type,
you may write the keyword `serial`.
Doing this specifies a *serial port instance*.
A serial port instance does not specify the type of data that it carries.
It may be connected to a port of any type.
Serial data passes through the port; the data may be converted to or from a
specific type at the other end of the connection.

As an example, here is a passive component for taking a stream
of serial data and splitting it (i.e., repeating it by copy)
onto several streams:

[source,fpp]
----
@ Split factor
constant splitFactor = 10

@ Component for splitting a serial data stream
passive component SerialSplitter {

  @ Input
  sync input port serialIn: serial

  @ Output
  output port serialOut: [splitFactor] serial

}
----

By using serial ports, you can send several unrelated types
of data over the same port connection.
This technique is useful when communicating across
a network: on each side of the network connection, a single component
can act as a hub that routs all data to and from components
on that side.
This flexibility comes at the cost that you lose the type
compile-time type checking provided by port connections with named types.
For more information about serial ports and their use, see
the https://github.com/nasa/fprime/blob/master/docs/UsersGuide/guide.md[F Prime User's Guide].

== Special Port Instances

A *special port instance* is a port instance that has a special
behavior in F Prime.
As discussed <<Defining-Components_Port-Instances,above>>,
when writing a general port instance,
you specify a port kind, a port type, and possibly other
information such as array size and priority.
Writing a special port instance is a bit different.
In this case you specify a predefined behavior
provided by the F Prime framework.
The special port behaviors fall into five groups:
commands, events, telemetry, parameters, and time.

== Command Ports

A *command* is an instruction to the spacecraft to perform an action.
The special command behaviors, and their keywords, are as follows:

* `command` `recv`: A port for receiving commands.
* `command` `reg`: A port for sending command registration requests.
* `command` `resp`: A port for sending command responses.

Collectively, these ports are known as *command ports*.
To specify a command port, you write one of the keyword pairs
shown above followed by the keyword `port` and the port name.

As an example, here is a passive component `CommandPorts` with each
of the command ports:

[source,fpp]
----
@ A component for illustrating command ports
passive component CommandPorts {

  @ A port for receiving commands
  command recv port cmdIn

  @ A port for sending command registration requests
  command reg port cmdRegOut

  @ A port for sending command responses
  command resp port cmdResponseOut

}
----

Any component may have at most one of each kind of command
port.
If a component receives commands (more on this below),
then all three ports are required.
The port names shown in the example above are standard but not
required; you can use any names you wish.

During translation, each command port is converted into
a typed port instance with a predefined port type, as follows:

* `command` `recv` uses the port `Fw.Cmd`
* `command` `reg` uses the port `Fw.CmdReg`
* `command` `resp` uses the port `Fw.CmdResponse`

The F Prime framework provides definitions for these ports
in the directory `Fw/Cmd`.
For checking simple examples, you can use the following
simplified definitions of these ports:

[source,fpp]
----
module Fw {
  port Cmd
  port CmdReg
  port CmdResponse
}
----

For example, to check the `CommandPorts` component, you can
add these lines before the component definition.
If you don't do this, or something similar, then the component
definition won't pass through `fpp-check` because of the missing ports.
(Try it and see.)

Note that the port definitions shown above are for conveniently checking
simple examples only.
They are not correct for the F Prime framework and will not work
properly with F Prime {cpp} code generation.

For further information about command registration, receipt, and
response, and implementing command handlers, see the
https://github.com/nasa/fprime/blob/master/docs/UsersGuide/guide.md[F Prime User's Guide].

== Event Ports

An *event* is a report that something happened, for example,
that a file was successfully uplinked.
The special event behaviors, and their keywords, are as follows:

* `event`: A port for emitting events as serialized bytes.
* `text` `event`: A port for emitting events as human-readable
text (usually used for testing and debugging on the ground).

Collectively, these ports are known as *event ports*.
To specify an event port, you write one of the keyword groups
shown above followed by the keyword `port` and the port name.

As an example, here is a passive component `EventPorts` with each
of the event ports:

[source,fpp]
----
@ A component for illustrating event ports
passive component EventPorts {

  @ A port for emitting events
  event port eventOut

  @ A port for emitting text events
  text event port textEventOut

}
----

Any component may have at most one of each kind of event
port.
If a component emits events (more on this below),
then both event ports are required.

During translation, each event port is converted into
a typed port instance with a predefined port type, as follows:

* `event` uses the port `Fw.Log`
* `text` `event` uses the port `Fw.LogText`

The name `Log` refers to an event log.
The F Prime framework provides definitions for these ports
in the directory `Fw/Log`.
For checking simple examples, you can use the following
simplified definitions of these ports:

[source,fpp]
----
module Fw {
  port Log
  port LogText
}
----

For further information about events in F Prime, see the
https://github.com/nasa/fprime/blob/master/docs/UsersGuide/guide.md[F Prime User's Guide].

== Telemetry Ports

*Telemetry* is data regarding the state of the system.
A *telemetry port* allows a component to emit telemetry.
To specify a telemetry port, you write the keyword `telemetry`,
the keyword `port`, and the port name.

As an example, here is a passive component `TelemetryPorts` with
a telemetry port:

[source,fpp]
----
@ A component for illustrating telemetry ports
passive component TelemetryPorts {

  @ A port for emitting telemetry
  telemetry port tlmOut

}
----

Any component may have at most one telemetry port.
If a component emits telemetry (more on this below),
then a telemetry port is required.

During translation, each telemetry port is converted into
a typed port instance with the predefined port type
`Fw.Tlm`.
The F Prime framework provides a definition for this port
in the directory `Fw/Tlm`.
For checking simple examples, you can use the following
simplified definition of this port:

[source,fpp]
----
module Fw {
  port Tlm
}
----

For further information about telemetry in F Prime, see the
https://github.com/nasa/fprime/blob/master/docs/UsersGuide/guide.md[F Prime User's Guide].

== Parameter Ports

A *parameter* is a configurable constant that may be updated
from the ground.
The current parameter values are stored in an F Prime component
called the *parameter database*.

The special parameter behaviors, and their keywords, are as follows:

* `param` `get`: A port for getting the current value of a parameter
from the parameter database.
* `param` `set`: A port for setting the current value of a parameter
in the parameter database.

Collectively, these ports are known as *parameter ports*.
To specify a parameter port, you write one of the keyword groups
shown above followed by the keyword `port` and the port name.

As an example, here is a passive component `ParamPorts` with each
of the parameter ports:

[source,fpp]
----
@ A component for illustrating parameter ports
passive component ParamPorts {

  @ A port for getting parameter values
  param get port prmGetOut

  @ A port for setting parameter values
  param set port prmSetOut

}
----

Any component may have at most one of each kind of parameter
port.
If a component has parameters (more on this below),
then both parameter ports are required.

During translation, each parameter port is converted into
a typed port instance with a predefined port type, as follows:

* `param` `get` uses the port `Fw.PrmGet`
* `param` `set` uses the port `Fw.PrmSet`

The F Prime framework provides definitions for these ports
in the directory `Fw/Prm`.
For checking simple examples, you can use the following
simplified definitions of these ports:

[source,fpp]
----
module Fw {
  port PrmGet
  port PrmSet
}
----

For further information about parameters in F Prime, see the
https://github.com/nasa/fprime/blob/master/docs/UsersGuide/guide.md[F Prime User's Guide].

== Time Get Ports

A *time get port* allows a component to get the system time from a
time component.
To specify a time get port, you write the keywords `time` `get`,
the keyword `port`, and the port name.

As an example, here is a passive component `TimeGetPorts` with
a time get port:

[source,fpp]
----
@ A component for illustrating time get ports
passive component TimeGetPorts {

  @ A port for getting the time
  time get port timeGetOut

}
----

Any component may have at most one time get port.
If a component emits events or telemetry (more on this below),
then a time get port is required, so that the events
and telemetry points can be time stamped.

During translation, each time get port is converted into
a typed port instance with the predefined port type
`Fw.Time`.
The F Prime framework provides a definition for this port
in the directory `Fw/Time`.
For checking simple examples, you can use the following
simplified definition of this port:

[source,fpp]
----
module Fw {
  port Time
}
----

For further information about time in F Prime, see the
https://github.com/nasa/fprime/blob/master/docs/UsersGuide/guide.md[F Prime User's Guide].

== Internal Ports

An *internal port* is a port that a component can use to send a
message to itself.
In the ordinary case, when a component sends a message, it invokes an
output port that is connected to an async input port.
When the output port and input port reside in the same component,
it is simpler to use an internal port.

As an example, suppose we have a component
that needs to send a message to itself.
We could construct such a component in the following way:

[source,fpp]
----
@ A data type T
type T

@ A port for sending data of type T
port P(t: T)

@ A component that sends data to itself on an async input port
active component ExternalSelfMessage {

  @ A port for sending data of type T
  async input port pIn: P

  @ A port for receiving data of type T
  output port pOut: P

}
----

This works, but if the only user of `pIn` is
`ExternalSelfMessage`, it is cumbersome.
We need to declare two ports and connect them.
Instead, we can use an internal port, like this:

[source,fpp]
----
@ A data type T
type T

@ A component that sends data to itself on an internal port
active component InternalSelfMessage {

  @ An internal port for sending data of type T
  internal port pInternal(t: T)

}
----

When the implementation of `ExternalSelfMessage` invokes
the port `pInternal`, a message goes on its queue.
This corresponds to the behavior of `pOut` in
`ExternalSelfMessage`.
Later, when the framework dispatches the message, it
calls a handler function associated with the port.
This corresponds to the behavior of `pIn` in
`ExternalSelfMessage`.
So an internal port is like two ports (an output port
and an async input port) fused into one.

When writing an internal port, you do not use a named
port definition.
Instead, you provide the formal parameters directly.
Notice that when defining `ExternalSelfMessage` we
defined and used the port `P`, but when defining
`InternalSelfMessage` we did not.
The formal parameters of an internal port work in the same way
as for a <<Defining-Ports_Formal-Parameters,port definition>>,
except that none of the parameters may be a
<<Defining-Ports_Reference-Parameters,reference parameter>>.

When specifying an internal port, you may specify
<<Defining-Components_Port-Instances_Priority,priority>> and
<<Defining-Components_Port-Instances_Queue-Full-Behavior,queue full behavior>>
as for an async input port.
For example, we can add priority and queue full behavior
to `pInternal` as follows:

[source,fpp]
----
@ A data type T
type T

@ A component that sends data to itself on an internal port,
@ with priority and queue full behavior
active component InternalSelfMessage {

  @ An internal port for sending data of type T
  internal port pInternal(t: T) priority 10 drop

}
----

Internal ports generate async input, so they make sense
only for `active` and `queued` components.
As an example, consider the following component
definition:

[source,fpp]
----
type T

passive component PassiveInternalPort {

  # Internal ports don't make sense for passive components
  internal port pInternal(t: T)

}
----


== Defining Port

A port definition defines an F Prime port. A port definition specifies the name of the port, the type of the data carried on the port, and an optional return type.

[source,fpp]
----
port <PortName>[(parameterName: ParameterType, ...)] [-> returnType]
----

== Port Name

The simplest port definition consists of the keyword `port` followed by a name. For example:

[source,fpp]
----
port MyPort
----

The provided code creates a port called MyPort that has no input or output data. Such a port can be useful for sending or receiving a trigger event.

== Port Parameters

In most cases, a port is used to transmit data. To specify the data, you can define port parameters by enclosing them in parentheses. The parameters in a port definition is similar to a function definition in a programming language. Each parameter has a name and a type, and you can include any number of parameters. Here's an example to illustrate this:

[source,fpp]
----
port P1() # Zero parameters; equivalent to port P1
port P2(a: U32) # One parameter
port P3(a: I32, b: F32, c: string) # Three parameters
----

The type of a formal parameter may be any valid type, including an array type, a struct type, an enum type, or an abstract type. For example, here is some code that defines an enum type E and and abstract type T, and then uses those types in the formal parameters of a port:

[source,fpp]
----
enum E { A, B }
type T
port P(e: E, t: T)
----

Parameters in a port definition are written as a sequence of elements, and they can be separated by commas. However, it is also acceptable to omit the comma and use a newline instead. This means that the definition mentioned earlier can be written in the following alternate format:

[source,fpp]
----
enum E { A, B }
type T
port P(
  e: E
  t: T
)
----

== Port Handler Functions

when constructing an F Prime application, you
instantiate port definitions as *output ports* and
*input ports* of component instances.
Output ports are connected to input ports.
For each output port `pOut` of a component instance `c1`,
there is a corresponding auto-generated function that the
implementation of `c1` can call in order to *invoke* `pOut`.
If `pOut` is connected to an input
port `pIn` of component instance `c2`, then invoking `pOut` runs a
*handler function* `pIn_handler` associated with `pIn`.
The handler function is part of the implementation of the component
`C2` that `c2` instantiates.
In this way `c1` can send data to `c2` or request
that `c2` take some action.
Each input port may be *synchronous* or *asynchronous*.
A synchronous invocation directly calls a handler function.
An asynchronous invocation calls a short function that puts
a message on a queue for later dispatch.
Dispatching the message calls the handler function.

*Translating handler functions:*
In FPP, each output port `pOut` or input port `pIn` has a *port type*.
This port type refers to an FPP port definition `P`.
In the {cpp} translation, the signature of a handler function
`pIn_handler` for `pIn`
is derived from `P`.
In particular, the {cpp} formal parameters of `pIn_handler`
correspond to the
<<Defining-Ports_Formal-Parameters,FPP formal parameters>> of `P`.

When generating the handler function `pIn_handler`, F
Prime translates each formal parameter _p_ of `P` in the following way:

. If _p_ carries a
<<Defining-Constants_Expressions_Primitive-Values,primitive value>>,
then _p_ is translated to a {cpp} value parameter.

. Otherwise _p_ is translated to a {cpp} `const` reference
parameter.

As an example, suppose that `P` looks like this:

[source,fpp]
----
type T
port P(a: U32, b: T)
----

Then the signature of `pIn_handler` might look like this:

[source,cpp]
----
virtual void pIn_handler(U32 a, const T& b);
----

*Calling handler functions:*
Suppose again that output port `pOut` of component instance `c1`
is connected to input port `pIn` of component instance `c2`.
Suppose that the implementation of `c1` invokes `pOut`.
What happens next depends on whether `pIn` is synchronous
or asynchronous.

If `pIn` is synchronous, then the invocation is a direct
call of the `pIn` handler function.
Any value parameter is passed by copying the value on
the stack.
Any `const` reference parameter provides a reference to
the data passed in by `c1` at the point of invocation.
For example, if `pIn` has the port type `P` shown above,
then the implementation of `pIn_handler` might look like this:

[source,cpp]
----
// Assume pIn is a synchronous input port
void C2::pIn_handler(U32 a, const T& b) {
  // a is a local copy of a U32 value
  // b is a const reference to T data passed in by c1
}
----

Usually the `const` reference is what you want, for efficiency reasons.
If you want a local copy of the data, you can make one.
For example:

[source,cpp]
----
// Copy b into b1
auto b1 = b
----

Now `b1` has the same data that the parameter `b` would have
if it were passed by value.

If `pIn` is asynchronous, then the invocation does not
call the handler directly. Instead, it calls
a function that puts a message on a queue.
The handler is called when the message is dispatched.
At this point, any value parameter is passed by
copying the value out of the queue and onto the stack.
Any `const` reference parameter is passed by
(1) copying data out of the queue and onto the stack and
(2) then providing a `const` reference to the data on the stack.
For example:

[source,cpp]
----
// Assume pIn is an asynchronous input port
void C2::pIn_handler(U32 a, const T& b) {
  // a is a local copy of a U32 value
  // b is a const reference to T data copied across the queue
  // and owned by this component
}
----

Note that unlike in the synchronous case, const references
in parameters refer to data owned by the handler
(residing on the handler stack),
not data owned by the invoking component.
Note also that the values must be small enough to permit
placement on the queue and on the stack.

If you want the handler and the invoking component to share data
passed in as a parameter, or if the data values are too large
for the queue and the stack, then you can use a data structure
that contains a pointer or a reference as a member.
For example, `T` could have a member that stores a reference
or a pointer to shared data.
F Prime provides a type `Fw::Buffer` that stores a
pointer to a shared data buffer.

== Reference Parameters

You may write the keyword `ref` in front of any formal parameter _p_
of a port definition.
Doing this specifies that _p_ is a *reference parameter*.
Each reference parameter in an FPP port becomes a mutable
{cpp} reference at the corresponding place in the
handler function signature.
For example, suppose this port definition

[source,fpp]
----
type T
port P(a: U32, b: T, ref c: T)
----

appears as the type of an input port `pIn` of component `C`.
The generated code for `C` might contain a handler function with a
signature like this:

[source,cpp]
----
virtual void pIn_handler(U32 a, const T& b, T& c);
----

Notice that parameter `b` is not marked `ref`, so it is
translated to `const T& b`, as discussed in the previous section.
On the other hand, parameter `c` is marked ref, so it
is translated to `T& c`.

Apart from the mutability, a reference parameter has the same
behavior as a `const` reference parameter, as described in
the previous section.
In particular:

* When `pIn` is synchronous, a reference parameter _p_ of `pIn_handler`
refers to the data passed in by the invoking component.

* When `pIn` is asynchronous, a reference parameter _p_ of `pIn_handler`
refers to data copied out of the queue and placed on the local stack.

The main reason to use a reference parameter is to
return a value to the sender by storing it through
the reference.
We discuss this pattern in the section on
<<Defining-Ports_Returning-Values,returning values>>.

== Returning Values

Optionally, you can give a port definition a return type.
To do this you write an arrow `pass:[->]` and a type
after the name and the formal parameters, if any.
For example:

[source,fpp]
----
type T
port P1 -> U32 # No parameters, returns U32
port P2(a: U32, b: F32) -> T # Two parameters, returns T
----

Invoking a port with a return type is like calling a function with
a return value.
Such a port may be used only in a synchronous context (i.e.,
as a direct function call, not as a message placed
on a concurrent queue).

In a synchronous context only, `ref` parameters provide another way to return
values on the port,
by assigning to the reference, instead of executing a {cpp} `return` statement.
As an example, consider the following two port definitions:

[source,fpp]
----
type T
port P1 -> T
port P2(ref t: T)
----

The similarities and differences are as follows:

. Both `P1` and `P2` must be used in a synchronous context,
because each returns a `T` value.

. In the generated {cpp} code,

.. The function for invoking `P1`
has no arguments and returns a `T` value.
A handler associated with `P1` returns a value of type `T`
via the {cpp} `return` statement.
For example:
+
----
T C::p1In_handler() {
  ...
  return T(1, 2, 3);
}
----

.. The function for invoking `P1` has one argument `t`
of type `T&`.
A handler associated with `P2` returns a value of type `T`
by updating the reference `t` (assigning to it, or updating
its fields).
For example:
+
----
void C::p2In_handler(T& t) {
  ...
  t = T(1, 2, 3);
}
----
+
+

The second way may involve less copying of data.

Finally, there can be any number of reference parameters,
but at most one return value.
So if you need to return multiple values on a port, then reference
parameters can be useful.
As an example, the following port attempts to update a result
value of type `U32`.
It does this via reference parameter.
It also returns a status value indicating whether the update
was successful.

[source,fpp]
----
enum Status { SUCCEED, FAIL }
port P(ref result: U32) -> Status
----

A handler for `P` might look like this:

----
Status C::pIn_handler(U32& result) {
  Status status = Status::FAIL;
  if (...) {
    ...
    result = ...
    status = Status::SUCCEED;
  }
  return status;
}
----

== Pass-by-Reference Semantics

Whenever a {cpp} formal parameter _p_ enables sharing of data between
an invoking component and a handler function `pIn_handler`,
we say that _p_ has *pass-by-reference semantics*.
Pass-by-reference semantics occurs in the following cases:

. _p_ has reference or `const` reference type,
and the port `pIn` is synchronous.

. _p_ has a type _T_ that contains a pointer or
a reference as a member.

When using pass-by-reference semantics,
you must carefully manage the
use of the data to avoid concurrency bugs
such as data races.
This is especially true for references that can modify
shared data.

Except in special cases that require special expertise (e.g.,
the implementation of highly concurrent data structures),
you should enforce the rule that at most
one component may use any piece of data at any time.
In particular, if component `A` passes a reference to component `B`,
then component `A` should not use the reference while
component `B` is using it, and vice versa.
For example:

. Suppose component `A` owns some data `D` and passes a reference
to `D` via a synchronous port call to component `B`.
Suppose the port handler in component `B` uses the data but
does not store the reference, so that when the handler exits,
the reference is lost.
This is a good pattern.
In this case, we may say that ownership of `D` resides in `A`, temporarily
goes to `B` for the life of the handler, and goes back to `A`
when the handler exits.
Because the port call is synchronous, the handler in `B`
never runs concurrently with any code in `A` that uses `D`.
So at most one of `A` or `B` uses `D` at any time.

. Suppose instead that the handler in `B` stores the reference
into a member variable, so that the reference
persists after the handler exits.
If this happens, then you should make sure that `A` cannot use
`D` unless and until `B` passes ownership of `D` to `A` and vice versa.
For example, you could use state variables of enum type in `A` and in `B` to
track ownership, and you could have a port invocation from `A` to `B` pass the
reference and transfer ownership from `A` to `B` and vice versa.

== Annotating a Port Definition

A port definition is an
<<Writing-Comments-and-Annotations_Annotations,annotatable element>>.
Each formal parameter is also an annotatable element.
Here is an example:

[source,fpp]
----
@ Pre annotation for port P
port P(
  @ Pre annotation for parameter a
  a: U32
  @ Pre annotation for parameter b
  b: F32
)
----

