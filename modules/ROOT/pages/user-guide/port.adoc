= Port

== What is F Prime Port

In the context of F Prime framework, a "port" refers to a communication interface that connects components within the flight software system. Ports serve as conduits for sending and receiving data, commands, events, or telemetry between different components. You can think of a port as the endpoint of a connection between two component instances.

image::fprime_ports.drawio.png[F Prime Port Illustration]

== Instantiating F Prime Ports

To use an F Prime port, the user needs to instantiate the port in the component's FPP specification. The port can be an instance of one of the F Prime predefined ports or one of the custom ports defined by the user. The process of defining custom ports will be covered later in this document.

Like in object-oriented programming, a "port instance" is created using a "port definition". The "port definition" holds information that applies to all instances of the port, like the type of data that can pass through it. On the other hand, the "port instance" contains specific details that are unique to its usage, such as the kind of port instance (async input, sync input, guarded input, output), the "port instance" name, and the type of instance which refers to the "port definition".

[source,fpp]
----
<async input, sync input, guarded input, output> port <PortInstanceName>: <PortType>
----

Here is an example of port instantiation:

[source,fpp]
----
active component Led {

    sync input port run: Svc.Sched

    output port gpioSet: Drv.GpioWrite
}
----

Let's break down the code:

`active component Led` line declares the start of a new component named "Led."

`sync input port run: Svc.Sched` line declares a synchronous input port named "run," which is associated with the "Svc.Sched" interface. The "Svc.Sched" interface represents a scheduler service will be repeating based on a given "rate group".

`output port gpioSet: Drv.GpioWrite` line declares an output port named "gpioSet," which is associated with the "Drv.GpioWrite" interface. The "Drv.GpioWrite" interface provides functionality to control the GPIO (General Purpose Input/Output) pins of a hardware device, such as setting the output state of a pin.

NOTE: Both the link:https://github.com/nasa/fprime/blob/master/Svc/Sched/Sched.fpp[Svc.Sched] and link:https://github.com/nasa/fprime/blob/master/Drv/GpioDriverPorts/GpioDriverPorts.fpp[Drv.GpioWrite] are predefined F Prime ports.


NOTE: Previously mentioned, there is a technical difference between a port type (defined outside any component, indicating the type of a port instance) and a port instance (defined inside a component, representing an instance of a port type). However, for the sake of simplicity, we will occasionally refer to a port instance as just a "port" in this manual, as long as it doesn't cause any confusion.

== Port Instance Kinds

A Port instance can have one of the following types:

* `async input`: This type of port receives input for the component through a message queue. The input is then processed either on the thread of the component itself (if the component is active) or on the thread of another port invocation (if the component is queued).
* `sync input`: This type of port receives input that directly invokes a handler defined within the component. The input is processed on the thread of the caller, the entity that triggered the input.
* `guarded input`: Similar to sync input, this type of port also receives input that invokes a handler within the component. However, the handler is guarded by a mutual exclusion lock, ensuring that only one thread can access it at a time to prevent conflicts or race conditions.
* `output`: This type of port is responsible for transmitting output from the component to other parts of the system or components. It facilitates the flow of information or data generated by the component to be used elsewhere.

[source,fpp]
----
port F32Value(value: F32)

passive component F32Adder {

  sync input port f32ValueIn1: F32Value

  sync input port f32ValueIn2: F32Value

  output port f32ValueOut: F32Value

}
----

The code above defines a component called "F32Adder" that performs addition on 32-bit floating-point values. Let's break down the code:

* `port F32Value(value: F32)`: This line defines a port type called F32Value, which represents a 32-bit floating-point value. The value parameter indicates that this port type expects a value of type F32.
* `passive component F32Adder`: This line defines a passive component called F32Adder. A passive component is a reusable module that doesn't have its own thread of execution and relies on external events to trigger its behavior.
* `sync input port f32ValueIn1`: F32Value: This line declares a synchronous input port called f32ValueIn1. Synchronous means that the component expects to receive data on this port and will wait for it to be available before proceeding. The port is of type F32Value, which means it can receive a 32-bit floating-point value.
* `sync input port f32ValueIn2`: F32Value: Similar to the previous line, this declares another synchronous input port called f32ValueIn2 of type F32Value.
* `output port f32ValueOut`: F32Value: This line declares an output port called f32ValueOut of type F32Value. This port will be used to send the result of the addition operation.

NOTE: The example code above doesn't explicitly show the implementation details of the addition operation, but it defines the input and output ports of the component.

== Rules for Port Instances

The port instances appearing in a component definition must
satisfy certain rules.
These rules ensure that the FPP model makes sense.

First, no passive component may have an `async` `input`
port.
This is because a passive component has no message queue,
so asynchronous input is not possible.
As an example, if we modify the input ports of our `F32Adder`
to make them `async`, we get an error.

[source,fpp]
--------
port F32Value(value: F32)

# Error: Passive component may not have async input
passive component ErroneousF32Adder {

  async input port f32ValueIn1: F32Value

  async input port f32ValueIn2: F32Value

  output port f32ValueOut: F32Value

}
--------

Try presenting this code to `fpp-check` and observe what happens.

Second, an active or queued component _must_ have asynchronous input.
That means it must have at least one async input port;
or it must have an internal port (described below);
or it must have at least one async command (also described below).
As an example, if we modify the input ports of our `ActiveF32Adder`
to make them `sync`, we get an error, because
there is no async input.

[source,fpp]
--------
port F32Value(value: F32)

# Error: Active component must have async input
active component ErroneousActiveF32Adder {

  sync input port f32ValueIn1: F32Value

  sync input port f32ValueIn2: F32Value

  output port f32ValueOut: F32Value

}
--------

Third, a port type appearing in an `async` `input` port
may not have a return type.
This is because returning a value
makes sense only for synchronous input.
As an example, this component definition is illegal:

[source,fpp]
--------
port P -> U32

active component Error {

  # Error: port instance p: P is async input and
  # port P has a return type
  async input port p: P

}
--------

== Defining Port

A port definition defines an F Prime port. A port definition specifies the name of the port, the type of the data carried on the port, and an optional return type.

[source,fpp]
----
port <PortName>[(parameterName: ParameterType, ...)] [-> returnType]
----

== Port Name

The simplest port definition consists of the keyword `port` followed by a name. For example:

[source,fpp]
----
port MyPort
----

The provided code creates a port called MyPort that has no input or output data. Such a port can be useful for sending or receiving a trigger event.

== Port Parameters

In most cases, a port is used to transmit data. To specify the data, you can define port parameters by enclosing them in parentheses. The parameters in a port definition is similar to a function definition in a programming language. Each parameter has a name and a type, and you can include any number of parameters. Here's an example to illustrate this:

[source,fpp]
----
port P1() # Zero parameters; equivalent to port P1
port P2(a: U32) # One parameter
port P3(a: I32, b: F32, c: string) # Three parameters
----

The type of a formal parameter may be any valid type, including an array type, a struct type, an enum type, or an abstract type. For example, here is some code that defines an enum type E and and abstract type T, and then uses those types in the formal parameters of a port:

[source,fpp]
----
enum E { A, B }
type T
port P(e: E, t: T)
----

Parameters in a port definition are written as a sequence of elements, and they can be separated by commas. However, it is also acceptable to omit the comma and use a newline instead. This means that the definition mentioned earlier can be written in the following alternate format:

[source,fpp]
----
enum E { A, B }
type T
port P(
  e: E
  t: T
)
----